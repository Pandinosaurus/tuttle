# Tutorial


The purpose of this tutorial is to explain, line by line, the [demo project](examples/musketeers) which
scans the the novel *The Three Musketeers*, to measure the importance of each musketeer. From a zip archive,
you will extract the text to produce this graph graph :

#SCREENSHOT

[png bar graph](http://abonnasseau.github.io/tuttle/docs/musketeers_assets/characters_count.png) and
a [csv file](http://abonnasseau.github.io/tuttle/docs/musketeers_assets/characters_count.csv) you can
import in our favorite spreadsheet software.

This tutorial works on Linux, and you'll need to install [`tuttle`](https://github.com/abonnasseau/tuttle/releases) as
well as [gnuplot](http://www.gnuplot.info/) . We'll use little python, gnuplot and shell code, but don't worry if
you don't know some of these languages : we'll focus on the method.

## Unzip the novel

In an empty directory, download the [zip](http://abonnasseau.github.io/tuttle/docs/musketeers_assets/Les_trois_mousquetaires.zip).
Then create a file called `tuttlefile` and paste this code :

    file://Les_trois_mousquetaires.txt <- file://Les_trois_mousquetaires.zip
        unzip Les_trois_mousquetaires.zip Les_trois_mousquetaires.txt

On line 1, we tell tuttle that we intend to produce Les_trois_mousquetaires.txt from the file Les_trois_mousquetaires.zip.
How do we acheive that ? With the shell code provided on line 2 : by calling online zip utility. Notice the indentation
 that delimits the code.

Let's run this workflow :

```console
lexman@lexman-pc:~$ cd tuttle_tutorial
lexman@lexman-pc:~/tuttle_tutorial$ tuttle run
============================================================
tuttlefile_1
============================================================
--- stdout : -----------------------------------------------
Archive:  Les_trois_mousquetaires.zip
  inflating: Les_trois_mousquetaires.txt

--- stderr : -----------------------------------------------
+ unzip Les_trois_mousquetaires.txt
lexman@lexman-pc:~/tuttle_tutorial$
====
Done
```

The output displays `tuttlefile_1` which the identifier of the *process* in the *workflow*. The identifier is made from
the filename `tuttlefile` and the line number of the process. After the identifier, we can see all the outputs
of the process.

We have ran our first *workflow*. We can take a look at our workspace :

```console
lexman@lexman-pc:~/tuttle_tutorial$ ls -la
total 1854
drwxrwx--- 1 lexman lexman    4096 mai   25 22:59 .
drwxrwx--- 1 lexman lexman    4096 mai   25 22:51 ..
-rwxrwx--- 1 lexman lexman 1389543 mai   24 20:27 Les_trois_mousquetaires.txt
-rwxrwx--- 1 lexman lexman  495538 mai   24 20:36 Les_trois_mousquetaires.zip
drwxrwx--- 1 lexman lexman       0 mai   25 22:57 .tuttle
-rwxrwx--- 1 lexman lexman     785 mai   25 23:00 tuttlefile

lexman@lexman-pc:~/tuttle_tutorial$ head Les_trois_mousquetaires.txt
PRÉFACE

dans laquelle il est établi que malgré leurs noms en os et en is, les héros de l'histoire que nous allons avoir l'honneur de raconter à
[...]
capricieux du poète n'est pas toujours ce qui impressionne la masse des lecteurs. Or, tout en admirant, comme les autres les admireront sans doute, les détails que nous avons signalés, la chose qui nous préoccupa le plus est une chose à laquelle bien certainement personne avant nous n'avait fait la moindre attention.
lexman@lexman-pc:~/tuttle_tutorial$
```

Well, the text is in french, but it does look like a novel, as we expected. We have produced our first *resource* :
the file Les_trois_mousquetaires.txt.

TODO : too early to speak about primary resource ?

Before we go on, take time to commit your work in your versioning system, eg `git`. You only need to commit the
`tuttlefile` and the *primary resource* Les_trois_mousquetaires.zip. Other *resources* like Les_trois_mousquetaires.txt
are generated by tuttle, so you can always retrieve full history from the sources.

## Count musketeers

For the next step, shell scripting won't be enough count the words in the text. We'll use a few lines of python for
parsing :

    file://characters_count.dat <- file://Les_trois_mousquetaires.txt !# python
        # -*- coding: utf8 -*-
        names = ["Athos", "Porthos", "Aramis", "d'Artagnan"]
        with open('characters_count.dat', 'w') as f_out:
            with open('Les_trois_mousquetaires.txt') as f_in:
                content = f_in.read()
            print("{} chars in the novel".format(len(content)))
            for name in names:
                f_out.write("{}\t{}\n".format(name, content.count(name)))
                print("{} - done".format(name))

At the end of line 1, `! python` tells tuttle to use the python *processor* to run the process. That means
the next lines will be executed as python code.

In a few words, this program loads all the text from The Three Musketeers in memory, and converts it to lower case
to ease comparison of text. Then for each name of musketeer, it converts it in lower case it counts the occurrences in
the text, in order to write a line in file characters_count.dat.

Let's run it :

```console
lexman@lexman-pc:~/tuttle_tutorial$ tuttle run
============================================================
tuttlefile_4
============================================================
--- stdout : -----------------------------------------------
1389543 chars in the novel
Athos - done
Porthos - done
Aramis - done
d'Artagnan - done
====
Done
lexman@lexman-pc:~/tuttle_tutorial$
```

You will notice tuttle only runs the necessary *processes* : The first process `tuttlefile_1` has already run, so only
the new process `tuttlefile_4` is executed.

Let's have a look at the result :

```console
lexman@lexman-pc:~/tuttle_tutorial$ cat characters_count.dat
Athos	968
Porthos	587
Aramis	523
D'Artagnan	367
lexman@lexman-pc:~/tuttle_tutorial$
```

Now have the figures in a tabular file that gnuplot can understand.

# TODO : generate report again

It's time to take a look at the report. Open the file
[`.tuttle/report.html`](http://abonnasseau.github.io/tuttle/doc/tutorial_assets/count_musketeers/tuttle_report.html)
inside the workspace.

## SCREENSHOT goes here

You can see everything that has happen in our workflow : duration of the processes,
whether they have failed, a graph of their dependencies. You can even download all the logs.


## Export to spreadsheet

Before go on with our graph, we'll answer to our cooker's curiosity : we all have this colleague next door interested
in the data we're processing :
*So I've heard you're counting the musketeers
 in The Three Musketeers... Would you mind sending me the files so that I could make my own graph in my spreadsheet ?*

Well, it requires no work to mail him the characters_count.dat file... But in fact his favorite spreadsheet software
can't open it : strings should be quoted, and columns needs to be separated by a comma instead of a tabulation... And
you must not omit windows new lines !

A simple line of awk does the trick :

    file://characters_count.csv <- file://characters_count.dat
        awk '{print "\""$1"\","$2"\r"}' characters_count.dat > characters_count.csv

After we've run the workflow, we get exactly what we expected :

    968,"Athos"^M
    587,"Porthos"^M
    523,"Aramis"^M
    367,"D'Artagnan"^M

Now we can mail him the new file, just after we have commited our work !

Adding the generation of this file in our *workflow* (and committing) will prove very usefull for updates, as you will
see later.


## Make the bar graph

Now we have data in a form that gnuplot understands. To make a graph from our data, gnuplot need this kind of program
on the standard input :

    set terminal png
    set output "characters_count.png"
    plot "characters_count.dat" using 2: xtic(1) with histogram

Tuttle does not have a gnuplot processor (... yet ! PR are welcome :), so we'll use the
[here doc](http://en.wikipedia.org/wiki/Here_document#Unix_shells) syntax to insert it in a standard shell *process* :

    file://characters_count.png <- file://characters_count.dat
        gnuplot <<$script$
        set terminal png
        set output "characters_count.png"
        plot "characters_count.dat" using 2: xtic(1) with histogram
        $script$

After we've ran tuttle, we can see the graph :
![Characters count](http://abonnasseau.github.io/tuttle/docs/musketeers_assets/characters_count.png)

It's time to commit our work once again.


## Fix the maths

But wait ? Have you seen this graph ? Do you truly believe the main character, D'Artagnan is mentioned two or three
times less thant his fellow companions ? There must have been an issue somewhere.

After a few verifications, you'll find that the main character's name can be `D'Artagnan` as well as `d'Artagnan`. In
fact `d'Artagnan` seems to be the correct way to spell it, and `D'Artagnan` is used only at the beginning of a sentence.

The right way to fix this is to change the python code to make it robust to case. You might have already noticed that we
usually don't find bugs as soon as we make them, but afterwards when we use some data previously computed. And
frequently our final users find tiny mistakes.

For this bug, we'll replace the former python process with this one, where all strings are converted to lower case
for comparison :

    file://characters_count.dat <- file://Les_trois_mousquetaires.txt !# python
        # -*- coding: utf8 -*-
        names = ["Athos", "Porthos", "Aramis", "d'Artagnan"]
        with open('characters_count.dat', 'w') as f_out:
            with open('Les_trois_mousquetaires.txt') as f_in:
                content_low = f_in.read().lower()
            print("{} chars in the novel".format(len(content_low)))
            for name in names:
                name_low = name.lower()
                f_out.write("{}\t{}\n".format(name, content_low.count(name_low)))
                print("{} - done".format(name))

Let's see what happens when we run this new process :

```console
lexman@lexman-pc:~/tuttle_tutorial$ tuttle run
The following resources are not valid any more and will be removed :
* file://characters_count.dat - Process code changed
* file://characters_count.png - Resource depends on file://characters_count.dat that have changed
0 seconds of processing will be lost
============================================================
tuttlefile_4
============================================================
--- stdout : -----------------------------------------------
1389543 chars in the novel
Athos - done
Porthos - done
Aramis - done
d'Artagnan - done

============================================================
tuttlefile_16
============================================================
--- stderr : -----------------------------------------------
+ gnuplot

Done
lexman@lexman-pc:~/tuttle_tutorial$
```

Tuttle has noticed the change. Before running the necessary *processes*, it cleans the workspace by deleting all the
*resources* that no longer fit with the current workflow.

So in our case, `characters_count.dat` is not valid any more because we have just changed the process that
produces it. And `characters_count.png` and `characters_count.csv` will be re-processed because they depend on the
former. Eventually, all the resources are up to date and coherent with your code.

By the way, do you remember this colleague who wanted a spreadsheet. It cost us no effort to mail him the update !


## Include bad guys

After a discussion with your teammates, you should count bad guys too, to have a reference. Michel is going to work on
that.

So he checks out the code from the repository on his own computer and changes the list of people to count :

    file://characters_count.dat <- file://Les_trois_mousquetaires.txt !# python
        # -*- coding: utf8 -*-
        names = ["Athos", "Porthos", "Aramis", "d'Artagnan", "Richelieu"]
        with open('characters_count.dat', 'w') as f_out:
            with open('Les_trois_mousquetaires.txt') as f_in:
                content_low = f_in.read().lower()
            print("{} chars in the novel".format(len(content_low)))
            for name in names:
                name_low = name.lower()
                f_out.write("{}\t{}\n".format(name, content_low.count(name_low)))
                print("{} - done".format(name))

When he executes `tuttle run` he can see the result, even make a few experiments, and when is work is over, he commits
and shares it to the central code repository.


Without `tuttle he would have to tell you that the python code he has changed. So you can delete `characters_count.dat`,
 but also `characters_count.png` and `characters_count.csv`, and recompute them.

Now, whih `tuttle`, the only thing you have to do to benefit from he work, is retrieve the modifications from the
versioning system (eg `git pull --rebase` if you work with git), and `tuttle run` : your teammate's work will be
incorporated into your, and it will only re-process what have changed.

With this feature from tuttle you can work on data as you work on code : use branches, merge with your team,
even use a continuous integration server like Jenkins that will always keep your data up-to-date !

## Improve the graph

After all this work, the project does what you want. But we can all agree this graph is really ugly...

It would be a lot nicer if it was drawn is green instead of red ! After reviewing the doc, it seem we only have to add
a line in the end :

    file://characters_count.png <- file://characters_count.dat
        gnuplot <<$script$
        set terminal png
        set output "characters_count.png"
        plot "characters_count.dat" using 2: xtic(1) with histogram
        linecolor "green"
        $script$

When we run the `tuttlefile`, we have this output :

```console
lexman@lexman-pc:~/tuttle_tutorial$ tuttle run
The following resources are not valid any more and will be removed :
* file://characters_count.png - Process code changed
0 seconds of processing will be lost
============================================================
tuttlefile_23
============================================================
--- stderr : -----------------------------------------------

TODO !

+ gnuplot

Done
lexman@lexman-pc:~/tuttle_tutorial$
```

Something went wrong !

Apparently, `gnuplot` didn't like our last raw. Let's have a look to the report in `.tuttle\report.html` :

First, you can't miss the workflow has failed, and which process is in error. You also notice that
`characters_count.png` is in red. It means that, according to the execution of the workflow,
you can't rely on the file `characters_count.png`.

Actually, as soon an error occurs, `tuttle` stops and leaves everything 'as is' so you can debug.

So let's have a look at files on the directory : we can see one called `characters_count.png`. This means that
gnuplot have produced it ! So what happened ? gnuplot has crashed **after** the png has been produced.

If you want to revert to a clean state, you can execute `tuttle invalidate` :

```console
lexman@lexman-pc:~/tuttle_tutorial$ tuttle invalidate
The following resources are not valid any more and will be removed :
* file://characters_count.png - Process code changed
0 seconds of processing will be lost
Done
lexman@lexman-pc:~/tuttle_tutorial$
```

`tuttle has removed all the files that where not valid, as we can see in the report :


In this state, we can rely on all the files we have.


But let's go on : we still want our green graph. Maybe color should be declared before drawing :

    file://characters_count.png <- file://characters_count.dat
        gnuplot <<$script$
        set terminal png
        set output "characters_count.png"
        linecolor "green"
        plot "characters_count.dat" using 2: xtic(1) with histogram
        $script$

Let's `tuttle run` :

```console
lexman@lexman-pc:~/tuttle_tutorial$ tuttle run
The following resources are not valid any more and will be removed :
* file://characters_count.png - Process code changed
0 seconds of processing will be lost
============================================================
tuttlefile_23
============================================================
--- stderr : -----------------------------------------------

TODO !

+ gnuplot

Done
lexman@lexman-pc:~/tuttle_tutorial$
```

Tuttle tried to get back from the updated process but an error occurred once again. Is it still our fault ? Well, if
rebooting windows solves many issues, why not `tuttle run` again ?

```console
lexman@lexman-pc:~/tuttle_tutorial$ tuttle run
tuttle has already failed

TODO

lexman@lexman-pc:~/tuttle_tutorial$
```

So ``tuttle` refused to run... Well, we haven't changed anything in the code, so why would the issue be fixed ?

The good way is to have a proper fix in to investigate, find the error change the tuttlefile accordingly. Actually,
the plot`doc says the color must be set on the same lin that the plot :

    file://characters_count.png <- file://characters_count.dat
        gnuplot <<$script$
        set terminal png
        set output "characters_count.png"
        plot "characters_count.dat" using 2: xtic(1) with histogram linecolor "green"
        $script$

`tuttlle run` :

```console
lexman@lexman-pc:~/tuttle_tutorial$ tuttle run
The following resources are not valid any more and will be removed :
* file://characters_count.png - Process code changed
0 seconds of processing will be lost
============================================================
tuttlefile_23
============================================================
--- stderr : -----------------------------------------------

TODO !

+ gnuplot

Done
lexman@lexman-pc:~/tuttle_tutorial$
```

There it is ! `tuttle` has seen the change in the code, it has removed invalid files, and have run the necessary
process... Now we can see our graph has the good color :

TODO

In this paragraph, we have seen how `tuttle` let you to investigate errors and fix them with few efforts because
you don't have to worrying about removing your previous work.


## Describe the plot in a separate file

Actually, the lines we have written are a kind of program, run by the gnuplot interpreter. This is very similar
 to python code.

You would usely create a separate file called `myplot.gnuplot`, with this content :

        set terminal png
        set output "characters_count.png"
        plot "characters_count.dat" using 2: xtic(1) with histeps linecolor "green"

and you would only have to run

        gnuplot myplot.gnuplot

But how can we benefit from reprocessing when the code change, with this language that have not been implemented in
`tuttle` ? We only have to add the code as a dependency :

    file://characters_count.png <- file://characters_count.dat, file://myplot.gnuplot
        gnuplot myplot.gnuplot


With this method, you can ensure re-processing of the png file when `myplot.gnuplot` changes.

## Follow the source file on the web

The first thing we have done at the beginning of this tuttorial was to download the zip file. The good news, is that
`tuttle` recognises http resources. You can even download it in one line :

    file://Les_trois_mousquetaires.zip <- http://abonnasseau.github.io/tuttle/docs/musketeers_assets/Les_trois_mousquetaires.zip ! download

That's all ! The `download` processor is smart enough to understand it has to download the http input resource into
the destination.

When we `tuttle run`, what will happen ? `tuttle` can't know for sure if the file `Les_trois_mousquetaires.zip` in
the workspace is the same as the remote one. Well not before it downloads it. Therefore, `tuttle` will invalidate the
file `Les_trois_mousquetaires.zip` and all its dependencies before downloading and running all the processes again...

Therefore, we can be absolutely sure the result of the workflow's execution is the correct.

Now, if the source changes on the internet, for example because the text is still being reviewed by volunteers who
compares the text to the scanned pages, it is easy to update !
`tuttle run` will notice the change in the source, will invalidate every thing that depends on it and run the necessary
processes again.

## Prevent for reprocessing too much

The drawback of the using remote resources, is that we don't always control them. What will happen it the resource
changes while we are working on the gnuplot part ? All the workflow could be invalidated !


That could be a problem if you have a long workflow... Imagine that our python process would begin 
by a heavy processing phase, like this `sleep(4)` instruction :

    file://characters_count.dat <- file://Les_trois_mousquetaires.txt !# python
        # -*- coding: utf8 -*-
        import time
        time.sleep(4)
        names = ["Athos", "Porthos", "Aramis", "d'Artagnan"]
        with open('characters_count.dat', 'w') as f_out:
            with open('Les_trois_mousquetaires.txt') as f_in:
                content_low = f_in.read().lower()
            print("{} chars in the novel".format(len(content_low)))
            for name in names:
                name_low = name.lower()
                f_out.write("{}\t{}\n".format(name, content_low.count(name_low)))
                print("{} - done".format(name))


To prevent from unexpected reprocessing, there is a `--threshold` parameter (in short `-t`) in the command line :
```console
lexman@lexman-pc:~/tuttle_tutorial$ tuttle run -t 2
TODO
Done
lexman@lexman-pc:~/tuttle_tutorial$
```

Here, we have defined that we don't want invalidation if it has to remove more than 2 seconds of processing. That's why
tuttle has stopped.

This feature can prove very usefull when you merge moficiations from your teammates.

## Bonus : detach from the web

Now let's see if you have understood how tuttle works. Suppose you want to work on our workflow in the
countryside where you don't have acces to Internet. If we run our workflow, `tuttle`will try to connect
to check if the Les_trois_mousquetaires.zip has changed remotely. Without connexion, the resource will
be considered as an error, so everything in the workflow would be invalidated. To prevent loosing our work
we want to disconnect from the remote resource by removing this line from the `tuttlefile` :

    file://Les_trois_mousquetaires.zip <- http://abonnasseau.github.io/tuttle/docs/musketeers_assets/Les_trois_mousquetaires.zip ! download

Now, ask yourself what will happen when we execute `tuttle run` ?

```console
lexman@lexman-pc:~/tuttle_tutorial$ tuttle run
The following resources are not valid any more and will be removed :
Nothing to do
lexman@lexman-pc:~/tuttle_tutorial$
```

What has happen ?

`Les_trois_mousquetaires.zip`is now a *primary resource*. When running, tuttle checks wheter the file
has changed since we last ran the workflow... And because it is the same, everything is still valid !

## Next :
DONE * show what happens when an error occurs... And fiw that error
DONE * show how to follow code changes even if the language is not implemented
DONE * show how to merge your work with you team mate's
Bonus :
* show the download processor... And how you can change (a bit) the workflow without loosing your work
DONE * explain the --threshold parameter to prevent from losing your work if a remote provider changes


## Conclusion
We've seen how to run a process with tuttle. In the incoming tutorial, you will learn how to deal with errors while you

work.